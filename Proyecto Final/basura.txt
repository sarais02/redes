 if(msg=="t"&&!canFinishMyTurn){ //TIRAR DADOS                              
                    int dado1= std::rand() %6 + 1;
                    int dado2= std::rand() %6 + 1;
                    int suma=dado1+dado2+indexPosition;
                    suma%=40;
                    if(suma<indexPosition && suma!=0) //Si suma justo es la salida no entra porq se sumaria 2 veces
                    {
                        PlayerSerializable player(nick,0,money,indexPlayer);//Muevo al jugador a la salida
                        socket.send(player,socket);
                    }
                    indexPosition=suma;
                                
                    std::cout<<"Tiro: "<<dado1<<" "<<dado2<<"\n";
                    std::cout<<"IndexPosition: "<<indexPosition<<"\n";              
                    PlayerSerializable player(nick,indexPosition,money,indexPlayer);//POR DEFECTO ES MOVER EL TIPO DE MENSAJE PLAYERSERIALIZABLE
                    socket.send(player,socket);
                    moverPlayer(indexPosition,&texturaJugador,0);
                }
                if(msg=="e"&&canFinishMyTurn){ //SI PUEDO ACABAR TURNO
                    std::cout<<"Acabo Mi Turno\n";
                    miTurno.setVisibility(false);
                    botones["comprarBoton"]->setVisibility(false);
                    Message initturno;
                    initturno.setType(ENDTURN);
                    socket.send(initturno, socket);
                    isMyTurn=false;
                    canBuySomething=false;
                    if(money<0){
                        onGame=false;
                        std::cout<<"BANCA ROTA\n";
                        for(auto it:playerProperties){
                            HipotecaMsg hipoteca(it.first,1);
                            socket.send(hipoteca,socket);
                        }
                    }
                }
                if(msg[0]=='e'&&!canFinishMyTurn)std::cout<<"No puedes acabar tu turno\n";

                if(msg=="c" && canBuySomething && compra.buyPrice<=money){ //SI PUEDO COMPRAR 
                    canBuySomething=false;
                    socket.send(compra,socket);                
                    money-=compra.buyPrice;
                    playerProperties.insert({compra.indexCasilla,compra.nombre});
                    std::cout<<"Calle Comprada\n";
                    botones["comprarBoton"]->setVisibility(false);                             
                }
                else if(msg[0]=='c' && canBuySomething && compra.buyPrice>money){
                    std::cout<<"No puedes comprar\n";
                }
                if(msg[0]=='m'){ //QUITAR
                    std::istringstream iss(msg);
                    std::string num;
                    std::getline(iss,num,' ');
                    std::getline(iss,num,' ');
                    int suma=std::stoi(num);
                    suma%=40;
                    if(suma<indexPosition && suma!=0) //Si suma justo es la salida no entra porq se sumaria 2 veces
                    {
                        PlayerSerializable player(nick,0,money,indexPlayer);//Muevo al jugador a la salida
                        socket.send(player,socket);
                    }
                    indexPosition=suma;

                    std::cout<<"IndexPosition: "<<indexPosition<<"\n";              
                    PlayerSerializable player(nick,indexPosition,money,indexPlayer);//POR DEFECTO ES MOVER EL TIPO DE MENSAJE PLAYERSERIALIZABLE
                    socket.send(player,socket);
                }
                 if(msg[0]=='h'){
                    std::istringstream iss(msg);
                    std::string num,hipotecar;
                    std::getline(iss,num,' ');
                    std::getline(iss,num,' ');
                    std::getline(iss,hipotecar,' ');               
                    int aux=hipotecar=="hipotecar"?1:0;              
                    HipotecaMsg hipoteca(std::stoi(num),aux);
                    socket.send(hipoteca,socket);
                }